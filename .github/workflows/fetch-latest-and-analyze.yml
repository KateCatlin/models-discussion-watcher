name: Fetch Latest and Analyze

on:
  workflow_dispatch:

jobs:
  get-latest:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Install Playwright
        run: |
          npm init -y
          npm install playwright

      - name: Install Playwright browsers
        run: npx playwright install --with-deps

      - name: Run script to fetch discussions
        run: node scripts/analyze-discussions.js

      - name: Analyze recent discussions with AI classification
        run: |
          # Check if discussions.json exists
          if [ ! -f "discussions.json" ]; then
            echo "discussions.json file not found. The fetching step may have failed."
            exit 1
          fi
          
          # Read the recent discussions data
          DISCUSSIONS=$(cat discussions.json)
          
          # Check if there are any recent discussions
          if [ "$(echo "$DISCUSSIONS" | jq 'length')" -eq 0 ]; then
            echo "No discussions found from the last 30 days. This may be normal if there haven't been any new discussions recently."
            echo "Creating empty analysis results..."
            echo '{"message": "No recent discussions found", "analyzed_discussions": []}' > analyzed-discussions.json
            exit 0
          fi
          
          # Create Node.js script for analysis
          cat > analyze.js << 'EOF'
          const fs = require('fs');
          
          // Simple AI-like analysis function to classify discussions as bug reports
          function classifyAsBugReport(title, author, commentCount) {
            const bugKeywords = [
              'bug', 'error', 'issue', 'problem', 'broken', 'not working', 'fail', 'crash',
              'exception', 'unexpected', 'wrong', 'incorrect', 'unable to', 'cannot',
              'doesn\'t work', 'does not work', 'regression', 'breaking', 'broken',
              'malfunction', 'glitch', 'defect', 'fault', 'anomaly'
            ];
            
            const featureKeywords = [
              'feature', 'request', 'enhancement', 'improvement', 'suggestion',
              'proposal', 'idea', 'add', 'support for', 'would be nice', 'could we',
              'please add', 'new feature', 'capability', 'functionality'
            ];
            
            const questionKeywords = [
              'how to', 'how do', 'question', 'help', 'clarification', 'documentation',
              'tutorial', 'guide', 'example', 'usage', 'best practice', 'recommend'
            ];
            
            const titleLower = title.toLowerCase();
            
            // Count keyword matches
            const bugScore = bugKeywords.reduce((count, keyword) => 
              count + (titleLower.includes(keyword) ? 1 : 0), 0);
            
            const featureScore = featureKeywords.reduce((count, keyword) => 
              count + (titleLower.includes(keyword) ? 1 : 0), 0);
            
            const questionScore = questionKeywords.reduce((count, keyword) => 
              count + (titleLower.includes(keyword) ? 1 : 0), 0);
            
            // Additional heuristics
            let confidence = 0;
            let classification = 'other';
            
            if (bugScore > 0) {
              classification = 'bug_report';
              confidence = Math.min(bugScore * 25, 90); // Max 90% confidence
              
              // Boost confidence for certain patterns
              if (titleLower.includes('error') || titleLower.includes('bug')) {
                confidence += 10;
              }
              if (titleLower.includes('not working') || titleLower.includes('broken')) {
                confidence += 15;
              }
            } else if (featureScore > 0) {
              classification = 'feature_request';
              confidence = Math.min(featureScore * 20, 80);
            } else if (questionScore > 0) {
              classification = 'question';
              confidence = Math.min(questionScore * 15, 70);
            } else {
              classification = 'discussion';
              confidence = 30; // Low confidence for general discussions
            }
            
            // Adjust confidence based on comment count (more comments might indicate a real issue)
            const commentNum = parseInt(commentCount) || 0;
            if (commentNum > 5 && classification === 'bug_report') {
              confidence += 5;
            }
            
            confidence = Math.min(confidence, 95); // Cap at 95%
            
            return {
              classification,
              confidence: Math.round(confidence),
              bugScore,
              featureScore,
              questionScore
            };
          }
          
          // Read discussions
          const discussions = JSON.parse(fs.readFileSync('discussions.json', 'utf8'));
          
          // Analyze each discussion
          const analyzedDiscussions = discussions.map(disc => {
            const analysis = classifyAsBugReport(disc.title, disc.author, disc.commentCount);
            return {
              ...disc,
              analysis
            };
          });
          
          const latest = analyzedDiscussions[0];
          
          console.log('=== MOST RECENT DISCUSSION (LAST 30 DAYS) ===');
          console.log(`Title: ${latest.title}`);
          console.log(`Author: ${latest.author}`);
          console.log(`Time: ${latest.datetime} (${latest.timeText || 'no relative time'})`);
          console.log(`Comments: ${latest.commentCount}`);
          console.log(`Classification: ${latest.analysis.classification} (${latest.analysis.confidence}% confidence)`);
          console.log(`URL: ${latest.url}`);
          
          console.log('\n=== RECENT DISCUSSIONS AI ANALYSIS SUMMARY ===');
          const bugReports = analyzedDiscussions.filter(d => d.analysis.classification === 'bug_report');
          const featureRequests = analyzedDiscussions.filter(d => d.analysis.classification === 'feature_request');
          const questions = analyzedDiscussions.filter(d => d.analysis.classification === 'question');
          const other = analyzedDiscussions.filter(d => d.analysis.classification === 'discussion');
          
          console.log(`Bug Reports: ${bugReports.length}`);
          console.log(`Feature Requests: ${featureRequests.length}`);
          console.log(`Questions: ${questions.length}`);
          console.log(`Other Discussions: ${other.length}`);
          
          console.log('\n=== BUG REPORTS IDENTIFIED (LAST 30 DAYS) ===');
          if (bugReports.length > 0) {
            bugReports.forEach((disc, i) => {
              console.log(`${i + 1}. ${disc.title}`);
              console.log(`   By: ${disc.author} | ${disc.timeText || disc.datetime} | ${disc.commentCount} comments`);
              console.log(`   Confidence: ${disc.analysis.confidence}%`);
              console.log(`   ${disc.url}`);
              console.log('');
            });
          } else {
            console.log('No bug reports identified in discussions from the last 30 days.');
          }
          
          console.log('\n=== ALL RECENT DISCUSSIONS WITH ANALYSIS ===');
          analyzedDiscussions.slice(0, 10).forEach((disc, i) => {
            const classificationEmoji = {
              'bug_report': 'üêõ',
              'feature_request': '‚ú®',
              'question': '‚ùì',
              'discussion': 'üí¨'
            };
            
            console.log(`${i + 1}. ${classificationEmoji[disc.analysis.classification]} ${disc.title}`);
            console.log(`   By: ${disc.author} | ${disc.timeText || disc.datetime} | ${disc.commentCount} comments`);
            console.log(`   Classification: ${disc.analysis.classification} (${disc.analysis.confidence}%)`);
            console.log(`   ${disc.url}`);
            console.log('');
          });
          
          // Save analyzed results
          fs.writeFileSync('analyzed-discussions.json', JSON.stringify(analyzedDiscussions, null, 2));
          EOF
          
          # Run the analysis
          node analyze.js
